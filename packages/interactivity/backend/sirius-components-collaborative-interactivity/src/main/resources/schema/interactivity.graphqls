extend type Query {
    interactivity(input: InteractivityModelInput!): InteractivityModelPayload!
    affectedElements(input: ComputeAffectedNodesInput!): ComputeAffectedElementsPayload!
}

input InteractivityModelInput {
    id: ID!
    editingContextId: ID!
    representationId: ID!
}

input ComputeAffectedNodesInput {
    id: ID!
    editingContextId: ID!
    representationId: ID!
    containerIds: [String!]!
}

union SemanticZoomPayload = SuccessPayload | ErrorPayload
union InteractivityModelPayload = InteractivityModelSuccessPayload | SuccessPayload | ErrorPayload
union ComputeAffectedElementsPayload = ComputeAffectedElementsSuccessPayload | SuccessPayload | ErrorPayload

type InteractivityModelSuccessPayload {
    id: ID!
    interactivity: Interactivity!
}

type ComputeAffectedElementsSuccessPayload {
    id: ID!
    affectedElementIds: [AffectedElementIdsPair!]!
}

type AffectedElementIdsPair {
    id: String!
    affectedElementIds: [String!]!
}

type Interactivity {
    domainId: String!
    diagramDefinition: DiagramDescription!
    features: [InteractiveFeature!]!
    filters: [FilterDefinition!]!
}

interface Identifiable {
    id: String!
}

union InteractiveFeature = SemanticZoom | DynamicFilter | SemanticSearch

type SemanticZoom {
    levels: [ZoomLevel!]!
}

type ZoomLevel {
    id: String!
    min: Int!
    max: Int!
    filter: FilterDefinition
}

type FilterDefinition {
    name: String!
    modifiers: [Modifier!]!
}

interface Modifier implements Identifiable {
    path: String!
    id: String!
}

type VisibilityModifier implements Modifier & Identifiable {
    path: String!
    hide: Boolean!
    id: String!
}

type StyleModifier implements Modifier & Identifiable {
    path: String!
    style: INodeStyle
    id: String!
}

type DynamicFilter {
    filters: [Filter!]!
    radius: Radius
}

type Filter implements Identifiable {
    reference: FilterDefinition
    name: String!
    focus: String!
    id: String!
}

union Radius = FixedRadius | BoundedRadius

type FixedRadius {
    value: Int!
}

type BoundedRadius {
    min: Int!
    max: Int!
}

type SemanticSearch implements Identifiable {
    search: String!
    id: String!
}